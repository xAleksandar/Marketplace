{"ast":null,"code":"const LOAD_HASHER = codeOrName => Promise.reject(new Error(`No hasher found for \"${codeOrName}\"`));\n\nexport class Multihashes {\n  constructor(options) {\n    this._hashersByName = {};\n    this._hashersByCode = {};\n    this._loadHasher = options.loadHasher || LOAD_HASHER;\n\n    for (const hasher of options.hashers) {\n      this.addHasher(hasher);\n    }\n  }\n\n  addHasher(hasher) {\n    if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {\n      throw new Error(`Resolver already exists for codec \"${hasher.name}\"`);\n    }\n\n    this._hashersByName[hasher.name] = hasher;\n    this._hashersByCode[hasher.code] = hasher;\n  }\n\n  removeHasher(hasher) {\n    delete this._hashersByName[hasher.name];\n    delete this._hashersByCode[hasher.code];\n  }\n\n  async getHasher(code) {\n    const table = typeof code === 'string' ? this._hashersByName : this._hashersByCode;\n\n    if (table[code]) {\n      return table[code];\n    }\n\n    const hasher = await this._loadHasher(code);\n\n    if (table[code] == null) {\n      this.addHasher(hasher);\n    }\n\n    return hasher;\n  }\n\n  listHashers() {\n    return Object.values(this._hashersByName);\n  }\n\n}","map":{"version":3,"sources":["/home/alex/Documents/gitest/Marketplace/node_modules/ipfs-core-utils/esm/src/multihashes.js"],"names":["LOAD_HASHER","codeOrName","Promise","reject","Error","Multihashes","constructor","options","_hashersByName","_hashersByCode","_loadHasher","loadHasher","hasher","hashers","addHasher","name","code","removeHasher","getHasher","table","listHashers","Object","values"],"mappings":"AAAA,MAAMA,WAAW,GAAGC,UAAU,IAAIC,OAAO,CAACC,MAAR,CAAe,IAAIC,KAAJ,CAAW,wBAAwBH,UAAY,GAA/C,CAAf,CAAlC;;AACA,OAAO,MAAMI,WAAN,CAAkB;AACvBC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,SAAKC,cAAL,GAAsB,EAAtB;AACA,SAAKC,cAAL,GAAsB,EAAtB;AACA,SAAKC,WAAL,GAAmBH,OAAO,CAACI,UAAR,IAAsBX,WAAzC;;AACA,SAAK,MAAMY,MAAX,IAAqBL,OAAO,CAACM,OAA7B,EAAsC;AACpC,WAAKC,SAAL,CAAeF,MAAf;AACD;AACF;;AACDE,EAAAA,SAAS,CAACF,MAAD,EAAS;AAChB,QAAI,KAAKJ,cAAL,CAAoBI,MAAM,CAACG,IAA3B,KAAoC,KAAKN,cAAL,CAAoBG,MAAM,CAACI,IAA3B,CAAxC,EAA0E;AACxE,YAAM,IAAIZ,KAAJ,CAAW,sCAAsCQ,MAAM,CAACG,IAAM,GAA9D,CAAN;AACD;;AACD,SAAKP,cAAL,CAAoBI,MAAM,CAACG,IAA3B,IAAmCH,MAAnC;AACA,SAAKH,cAAL,CAAoBG,MAAM,CAACI,IAA3B,IAAmCJ,MAAnC;AACD;;AACDK,EAAAA,YAAY,CAACL,MAAD,EAAS;AACnB,WAAO,KAAKJ,cAAL,CAAoBI,MAAM,CAACG,IAA3B,CAAP;AACA,WAAO,KAAKN,cAAL,CAAoBG,MAAM,CAACI,IAA3B,CAAP;AACD;;AACc,QAATE,SAAS,CAACF,IAAD,EAAO;AACpB,UAAMG,KAAK,GAAG,OAAOH,IAAP,KAAgB,QAAhB,GAA2B,KAAKR,cAAhC,GAAiD,KAAKC,cAApE;;AACA,QAAIU,KAAK,CAACH,IAAD,CAAT,EAAiB;AACf,aAAOG,KAAK,CAACH,IAAD,CAAZ;AACD;;AACD,UAAMJ,MAAM,GAAG,MAAM,KAAKF,WAAL,CAAiBM,IAAjB,CAArB;;AACA,QAAIG,KAAK,CAACH,IAAD,CAAL,IAAe,IAAnB,EAAyB;AACvB,WAAKF,SAAL,CAAeF,MAAf;AACD;;AACD,WAAOA,MAAP;AACD;;AACDQ,EAAAA,WAAW,GAAG;AACZ,WAAOC,MAAM,CAACC,MAAP,CAAc,KAAKd,cAAnB,CAAP;AACD;;AAjCsB","sourcesContent":["const LOAD_HASHER = codeOrName => Promise.reject(new Error(`No hasher found for \"${ codeOrName }\"`));\nexport class Multihashes {\n  constructor(options) {\n    this._hashersByName = {};\n    this._hashersByCode = {};\n    this._loadHasher = options.loadHasher || LOAD_HASHER;\n    for (const hasher of options.hashers) {\n      this.addHasher(hasher);\n    }\n  }\n  addHasher(hasher) {\n    if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {\n      throw new Error(`Resolver already exists for codec \"${ hasher.name }\"`);\n    }\n    this._hashersByName[hasher.name] = hasher;\n    this._hashersByCode[hasher.code] = hasher;\n  }\n  removeHasher(hasher) {\n    delete this._hashersByName[hasher.name];\n    delete this._hashersByCode[hasher.code];\n  }\n  async getHasher(code) {\n    const table = typeof code === 'string' ? this._hashersByName : this._hashersByCode;\n    if (table[code]) {\n      return table[code];\n    }\n    const hasher = await this._loadHasher(code);\n    if (table[code] == null) {\n      this.addHasher(hasher);\n    }\n    return hasher;\n  }\n  listHashers() {\n    return Object.values(this._hashersByName);\n  }\n}"]},"metadata":{},"sourceType":"module"}